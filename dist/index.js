!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("colorette")):"function"==typeof define&&define.amd?define(["colorette"],e):(t="undefined"!=typeof globalThis?globalThis:t||self).index=e(t.colorette)}(this,(function(t){"use strict";function e(t){for(const e in t)return!1;return!0}function n(t,e){const n=[];let r=-e.length,s=0;if(!t)return n;for(;s<t.length;)t[s]==e?(n.push(t.substring(r+e.length,s)),r=s,s+=e.length):e?s++:n.push(t[s++]);return e&&n.push(t.substring(r+e.length,t.length)),n}const r=t=>(1==t.length?"-":"--")+t,s=e=>`Found argument '${t.yellow(r(e))}' which wasn't expected, or isn't valid in this context.`,a=e=>`Empty argument '${t.yellow(e)}' which wasn't expected.`,o=(e,n)=>`Invalid arugments for flag '${t.yellow(e)}', ${n}.`,i=`Invalid formating flag, need to be '${t.yellow("flag")}=${t.yellow("value")}(${t.yellow(",value...")})'.`,l=(e,n)=>`flags '${t.yellow(r(e))}' need flags '${t.yellow(r(n))}'`,h=`need a valid boolean, choice are '${t.italic(t.yellow("true"))}' or '${t.italic(t.yellow("false"))}'.`,d=`need a valid '${t.italic(t.yellow("number"))}'.`,c=`need a valid '${t.italic(t.yellow("date"))}'.`;return class{constructor(t,e,n={}){this.name=t,this.description=e,this.commands={},this.arguments={},this.errors=[],this.argv=[],this.options=Object.assign({defaultArg:!0},n),this.options.defaultArg&&(this.addArgument("help",{alias:"h",description:"Prints help information",call({parser:t}){t.usage()}}),this.options.version&&this.addArgument("version",{alias:"v",description:"Print version info and exit",call({options:t,name:e}){console.info(`${e} ${t.version}`)}}))}checkArguments(t,e){if(e.name in this.arguments)throw new Error(`duplicate options '${e.name}'`);if(e.name.length<2)throw new Error(`name arguments '${e.name}' need to be upper than one char`);if(this.options.inline&&function(t,e){for(let n=0;n<t.length;n++)if(t[n]===e)return!0;return!1}(e.name,"="))throw new Error(`name arguments '${e.name}' can't contains '=' in here name`);e.params?e.params.forEach((t=>{if(void 0===t.type)throw new Error(`arguments '${e.name}' not have 'type'`)})):e.params=[];const n=e.alias;if(n){if(void 0!==t[n])throw new Error(`duplicate alias options '${n}`);if(1!=n.length)throw new Error(`alias options '${n}' need to be only one char`);t[n]=e}}addArgument(t,e={}){const n=e;n.name=t,this.checkArguments(this.arguments,n),this.arguments[t]=n}addCommand(t,e,n={}){if(t in this.commands)throw new Error(`Command '${t}' already set`);if(t.length<=1)throw new Error(`Command '${t}' need to be more length`);const r=n;if(r.name=t,r.description=e,n.arguments){const t=Object.assign({},r.arguments);for(const e in n.arguments)r.arguments[e].name=e,this.checkArguments(t,r.arguments[e]);r.arguments=t}else r.arguments={};this.options.defaultArg&&!r.arguments.help&&(r.arguments.help=Object.assign({},this.arguments.help),r.arguments.help.call=()=>{this.commandUsage(r.name)}),this.commands[t]=r}checkDefault(e){if(void 0!==e.default)return e.default;throw new Error((n=e.type,`need '${t.yellow(n.constructor.name.toLowerCase())}' arguments.`));var n}convertValue(t,e,n){if(e.validator)return e.validator(n,t);if(e.type==Number){const t=Number(n);if(Number.isNaN(t))throw new Error(d);return t}if(e.type===Boolean)switch(n){case"true":case"yes":return!0;case"false":case"no":return!1;default:throw new Error(h)}else if(e.type==Date){const t=new Date(n);if(isNaN(t.getTime()))throw new Error(c);return t}return n}advFlagInline(e,s,a,l,h){const d=a[h[0]],c=[];if(l[d.name]=c,d.alias&&(l[d.alias]=c),2!=h.length)return this.addError(i,s,2),s+1;const m=n(h[1],",");if(m.length>d.params.length)return this.addError((g=d.name,u=d.params.length,`Need ${t.yellow(u)} arguments after flag '${t.yellow(r(g))}'.`),s,h[0].length+2),s+1;var g,u;let p=2+d.name.length+1;for(let t=0;t<d.params.length;t++){const e=d.params[t],n=t>=m.length;try{n?c.push(this.checkDefault(e)):c.push(this.convertValue(c,e,m[t]))}catch(e){this.addError(o(d.name,e.message),s,p,n?0:m[t].length)}finally{n||(p+=m[t].length+1)}}return s+1}advFlag(t,e,n,r,s){const a=[];if(n[r.name]=a,r.alias&&(n[r.alias]=a),!r.params.length)return e;let i=0;for(let n=0;n<r.params.length;n++){const l=r.params[n],h=e+n>=t.length,d=!h&&l.type!==Number&&"-"===t[e+n][0]||!1;try{d?(i++,a.push(this.checkDefault(l))):h?a.push(this.checkDefault(l)):a.push(this.convertValue(a,l,t[e+n]))}catch(t){return this.addError(o(s,t.message),e),e}}return e+r.params.length-i}parseMulti(t,e,r,o,i,l){if(2==r.length)return this.addError(a("--"),l,2,r.length-2),l+1;const h=r.substring(2),d=this.options.inline?n(h,"="):[h];return void 0===o[d[0]]?(this.addError(s(h),l,2,r.length-2),l+1):this.options.inline&&1!=d.length?(i[d[0]]={argvi:l,start:2,end:d[0].length},this.advFlagInline(e,l,o,t,d)):(i[h]={argvi:l,start:2},this.advFlag(e,l+1,t,o[h],h))}parseSimple(t,e,n,r,a,o){let i=o;for(let l=1;l<=n.length-1;l++){const h=r[n[l]];void 0!==h?(a[n[l]]={argvi:i,start:l,end:1},i=this.advFlag(e,i+1,t,h,n[l])):this.addError(s(n[l]),o,l,1)}return Math.max(o+1,i)}parseFlags(t,e,n=0){const r={},s={},o=[];for(;n<t.length;){const i=t[n];if(t[n]===this.options.stopFlags){n++;break}"-"!=i[0]?(o.push(i),n++):"-"==i[1]?n=this.parseMulti(r,t,i,e,s,n):1!=i.length?n=this.parseSimple(r,t,i,e,s,n):this.addError(a("-"),n++)}for(;n<t.length;)o.push(t[n++]);return[r,o,s]}checkArgDepend(t){var e;for(const n in t){const r=t[n];if(r.depends&&r.depends.length){if(new Set(r.depends).size!=(null===(e=r.depends)||void 0===e?void 0:e.length))throw new Error(`duplicate depend name in flag '${r.name}'`);r.depends.forEach((e=>{const n=typeof e;if("string"!==n)throw new Error(`depend name '${e}' need to be a string, not '${n}'`);if(1==e.length)throw new Error(`depend '${e}' c'ant be a alias`);if(!(e in t))throw new Error(`c'ant find '${e}' in arguments`)}))}}}parse(n){if(this.argv=n,0==n.length)return this.usage(),!0;let r,s=this.arguments;if(!e(this.commands)){if(!(n[0]in this.commands))return this.addError("-"==n[0][0]?(e=>`First argument '${t.yellow(e)}' need to be a command, not flags.`)(n[0]):(e=>`No Such command '${t.yellow(e)}'.`)(n[0]),0),!1;r=this.commands[n[0]],s=Object.assign(Object.assign({},s),r.arguments)}this.checkArgDepend(s);const[a,o,i]=this.parseFlags(n,s,r?1:0);this.checkDependFlags(i,s,a);const l=this.createContext(a,o,r);if(this.errors.length)return!1;const h=this.getCall(a,s,r);return h&&h(l),!0}getCall(t,e,n){for(const n in t){const t=e[n].call;if(t)return t}if(n&&n.call)return n.call}checkDependFlags(t,e,n){const r=[];for(const s in t){const a=e[s];a.depends&&a.depends.length&&a.depends.forEach((e=>{if(!(e in n)){r.find((t=>(t[0]===s||t[0]===a.alias)&&t[1]===e))||(r.push([s,e]),this.addError(l(s,e),t[s].argvi,t[s].start,t[s].end))}}))}}get context(){if(void 0===this.ctx)throw new Error("You need to call 'parse' before access context");return this.ctx}createContext(t,e,n){return this.ctx={flags:t,anyArgs:e,parser:this,name:this.name,description:this.description,options:this.options,argv:this.argv},n&&(this.ctx.cmd=n),this.ctx}addError(t,e,n,r){const s=this.errors.find((t=>t.argvi===e&&t.start===n&&t.end===r));s?s.text.push(t):this.errors.push({text:[t],argvi:e,start:n,end:r})}printError(e){const n=`${this.name} ${this.argv.join(" ")}\n`,r=void 0===e?this.errors:[...this.errors].splice(0,e);let s="";if(r.forEach((e=>{var r,a,o;s+=`${t.red(t.bold("error"))}: ${e.text.join("\n"+" ".repeat(7))}\n`;let i=e.argvi+this.name.length+1;for(let t=0;t<e.argvi;t++)i+=this.argv[t].length;s+=`${n}${" ".repeat(i)}`;const l=(null===(r=this.argv[e.argvi])||void 0===r?void 0:r.length)||1;e.start=null!==(a=e.start)&&void 0!==a?a:0,e.end=null!==(o=e.end)&&void 0!==o?o:l-e.start,s+=t.red("~".repeat(e.start))+t.red(t.bold("^".repeat(e.end)));const h=l-(e.start+e.end);h>0&&(s+=t.red("~".repeat(h))),s+="\n"})),this.errors.length>=5){const e=this.errors.reduce(((t,e)=>e.text.length+t),0);s+=`total errors: ${t.red(t.bold(e))}`}console.error(s.trim())}formatOptions(e,n="Options:"){var r;const s={};for(const t in e)s[e[t].name]=e[t];const a={};let o=0;for(const t in s){const e=s[t];a[t]=t.length,e.params&&e.params.length&&(a[t]+=e.params.reduce(((t,e)=>t+e.type.name.length+3),0)),o=Math.max(o,a[t])}let i=n+"\n";for(const e in s){const n=s[e];i+=`${n.alias?`-${n.alias}, `:"    "}--${e}`,n.params&&(i+=n.params.reduce(((t,e)=>`${t}<${e.type.constructor.name.toLowerCase()}> `),"")),i+=`${" ".repeat(o-a[e]+1)}${null!==(r=n.description)&&void 0!==r?r:t.italic("no information.")}\n`}return i}formatCommands(t){let e=0;for(const n in t)e=Math.max(e,n.length);let n="Commands:\n";for(const r in t)n+=`  ${r}${" ".repeat(e-r.length)} ${t[r].description}\n`;return n}commandUsage(t){var e;if("string"==typeof t){const e=this.commands[t];if(!e)throw new Error(`not found '${t}' command.`);t=e}let n=`Usage: ${this.name} ${t.name} `;n+=`${null!==(e=this.options.info)&&void 0!==e?e:"[OPTIONS]\n\n"}${t.description}`,this.arguments&&(n+="\n\n"+this.formatOptions(this.arguments,"Global options:")),t.arguments&&(n+="\n\n"+this.formatOptions(t.arguments,"Command options:")),this.options.footer&&(n+=`\n\n${this.options.footer}`),console.log(n.trim())}usage(){var t;let n=`Usage: ${this.name} `;n+=null!==(t=this.options.info)&&void 0!==t?t:(e(this.commands)?"":"COMMAND")+" [OPTIONS]\n\n",n+=this.description,e(this.arguments)||(n+="\n\n"+this.formatOptions(this.arguments)),e(this.commands)||(n+="\n\n"+this.formatCommands(this.commands)),this.options.footer&&(n+=`\n\n${this.options.footer}`),console.info(n.trim())}}}));
